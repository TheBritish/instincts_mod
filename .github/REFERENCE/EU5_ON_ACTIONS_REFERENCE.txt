## EU5 On Actions Reference
## Source: https://eu5.paradoxwikis.com/On_actions
## Last Updated: December 5, 2025

âœ… **COMPREHENSIVE DOCUMENTATION AVAILABLE**
This is the complete on actions reference for Europa Universalis V.

======================
WHAT ARE ON ACTIONS?
======================

On actions are effects called automatically by specific game circumstances or triggers.
They are the game's event system backbone, determining when and how events fire.

Think of on actions as "hooks" into game events:
- Monthly pulse â†’ fires every month
- on_new_ruler â†’ fires when ruler changes
- on_war_declared â†’ fires when war starts
- on_character_death â†’ fires when character dies

On actions allow modders to attach custom events and effects to game occurrences without
modifying game code.

======================
ON ACTION TYPES
======================

PULSE ON ACTIONS
----------------------------------
Fire on regular intervals:

monthly_country_pulse              # Every month
yearly_country_pulse               # Every year
biyearly_country_pulse             # Every 2 years
four_yearly_country_pulse          # Every 4 years

EVENT-TRIGGERED ON ACTIONS
----------------------------------
Fire when specific events occur:

on_new_ruler                       # Ruler changes
on_character_death                 # Character dies
on_war_declared                    # War declared
on_location_occupied               # Province captured
on_battle_won                      # Battle victory

HARDCODED vs SCRIPTED
----------------------------------
**Hardcoded**: Called directly by game engine code
- You cannot create new hardcoded on actions
- Can only add to existing ones

**Scripted**: Called by other on actions or effects
- You can create custom scripted on actions
- Called via trigger_event effect

======================
ON ACTION STRUCTURE
======================

BASIC TEMPLATE
----------------------------------
on_action_name = {
    trigger = {
        # Conditions for on action to fire
        trigger_conditions = yes
    }
    
    weight_multiplier = {
        # Used for random selection weight
        base = 1
        modifier = {
            add = 1
            trigger_conditions = yes
        }
    }
    
    events = {
        # Events that always fire (if trigger = yes)
        event_id.1
        event_id.2
    }
    
    random_events = {
        # Pick one event randomly
        chance_to_happen = 25  # % chance to evaluate
        
        chance_of_no_event = {
            value = 10         # % chance no event fires
        }
        
        100 = event_id.1       # Weight 100
        200 = event_id.2       # Weight 200 (2x more likely)
        100 = 0                # Weight 100 for "no event"
    }
    
    first_valid = {
        # Pick first event with valid trigger
        event_id.1
        event_id.2
        fallback_event       # No trigger (always valid)
    }
    
    on_actions = {
        # Call other on actions
        other_on_action_1
        other_on_action_2
    }
    
    random_on_actions = {
        # Pick one on action randomly
        100 = on_action_1
        200 = on_action_2
    }
    
    first_valid_on_action = {
        # Pick first valid on action
        on_action_1
        on_action_2
    }
    
    effect = {
        # Direct effects
        effects = yes
    }
    
    fallback = another_on_action  # Called if nothing fires
}

ON ACTION BLOCKS
----------------------------------
| Block | Description |
|-------|-------------|
| trigger | Conditions for on action to fire |
| events | Events that always fire (if trigger valid) |
| random_events | One random event from list |
| first_valid | First event with valid trigger |
| on_actions | Other on actions to call |
| random_on_actions | One random on action from list |
| first_valid_on_action | First valid on action |
| effect | Direct effects to execute |
| weight_multiplier | Weight for random selection |
| fallback | Fallback on action if nothing fires |

======================
DELAYS
======================

BASIC DELAY
----------------------------------
events = {
    event_id.1                     # Fires immediately
    
    delay = { days = 30 }
    event_id.2                     # Fires after 30 days
    
    delay = { months = 6 }
    event_id.3                     # Fires after 6 months
}

RANDOM DELAYS
----------------------------------
delay = { days = { 10 30 } }       # Random 10-30 days
delay = { months = { 6 12 } }      # Random 6-12 months
delay = { years = { 1 3 } }        # Random 1-3 years

DELAY OVERRIDING
----------------------------------
delay = { days = 30 }
event_id.1                         # 30 days
event_id.2                         # Still 30 days

delay = { months = 6 }
event_id.3                         # 6 months (overrides previous)

DELAY VALIDATION
----------------------------------
âš ï¸ **IMPORTANT**: For performance, events only fire if valid BOTH:
1. When on action is triggered
2. When delay completes

If conditions change during delay, event may not fire!

======================
MODDING ON ACTIONS
======================

ADDING TO EXISTING ON ACTIONS
----------------------------------
âš ï¸ **Can ONLY add on_actions block to existing on actions!**
Adding other blocks causes errors.

# âœ… CORRECT:
on_monthly_pulse_country = {
    on_actions = {
        my_mod_monthly_pulse  # Your custom on action
    }
}

my_mod_monthly_pulse = {
    trigger = {
        # Your conditions
    }
    
    events = {
        my_mod.1
        my_mod.2
    }
}

# âŒ WRONG:
on_monthly_pulse_country = {
    events = {              # ERROR! Can't add events directly
        my_mod.1
    }
}

NAMING CONVENTIONS
----------------------------------
âœ… Use unique prefix for compatibility:
my_mod_monthly_check
mymod_on_ruler_change

âŒ Avoid generic names:
monthly_pulse               # Conflicts with other mods
custom_check                # Too generic

CREATING SCRIPTED ON ACTIONS
----------------------------------
# Define your on action:
my_mod_investigation_pulse = {
    trigger = {
        has_variable = investigation_active
    }
    
    random_events = {
        chance_to_happen = 50
        
        100 = investigation_event.1
        200 = investigation_event.2
        100 = 0  # 25% chance nothing happens
    }
}

# Call from another on action:
on_monthly_pulse_country = {
    on_actions = {
        my_mod_investigation_pulse
    }
}

======================
CALLING ON ACTIONS
======================

FROM EFFECTS
----------------------------------
# Call on action directly:
trigger_event = {
    on_action = my_custom_on_action
}

# With delay:
trigger_event = {
    on_action = my_custom_on_action
    days = 30
    months = 6
    years = 1
}

# Silent (no notifications):
trigger_event_silently = {
    on_action = my_custom_on_action
    days = 30
}

# Non-silent (default):
trigger_event_non_silently = {
    on_action = my_custom_on_action
}

======================
SCOPE CONTEXT
======================

DEFAULT SCOPES
----------------------------------
Each on action has a specified root scope and additional scopes:

on_new_ruler = {
    # root = country
    # scope:old_ruler = previous ruler character
    # scope:new_ruler = new ruler character
}

on_war_declared = {
    # root = country (attacker)
    # scope:actor = attacker country
    # scope:recipient = defender country
    # scope:war = war object
}

on_battle_won = {
    # root = country (winner)
    # scope:actor = winning unit
    # scope:target = losing unit
    # scope:killed_land_units = number killed
    # scope:war_score = war score change
}

ACCESSING SCOPES IN EVENTS
----------------------------------
# In event triggered by on_new_ruler:
event = {
    id = my_event.1
    
    trigger = {
        # root is country
        stability >= 1
        
        # Access old ruler
        scope:old_ruler = {
            age >= 50
        }
    }
    
    immediate = {
        scope:new_ruler = {
            add_trait = inherited_crown
        }
    }
}

======================
PARALLELIZATION
======================

PERFORMANCE OPTIMIZATION
----------------------------------
The "events" block in on actions is PARALLELIZED:
- Multiple scopes processed simultaneously
- Uses available CPU threads
- Much faster than sequential processing

IMPLICATIONS
----------------------------------
1. **Unpredictable order**: Scopes processed in arbitrary order
2. **Isolated execution**: Each scope's event runs independently
3. **No shared state**: Can't rely on changes from other scopes

BEST PRACTICE
----------------------------------
âœ… Use events block for better performance when affecting many scopes:
on_monthly_pulse_country = {
    events = {
        my_event.1  # Parallelized across all countries
    }
}

âŒ Don't use effect block for many scopes:
on_monthly_pulse_country = {
    effect = {
        # Runs sequentially for each country - SLOW!
        add_prestige = 1
    }
}

ORDERING REQUIREMENTS
----------------------------------
If you need specific execution order:

# âŒ Don't rely on parallel execution:
events = {
    event_a.1  # No guarantee this fires before event_b.1
    event_b.1
}

# âœ… Use ordered_list or chain events:
effect = {
    ordered_list = {
        trigger_event = event_a.1
        trigger_event = event_b.1  # Fires after event_a.1
    }
}

======================
COMMON ON ACTIONS
======================

PULSE ON ACTIONS
----------------------------------
**Monthly**
monthly_country_pulse              # Every country, every month
weather_monthly_pulse              # Weather system updates

**Yearly**
yearly_country_pulse               # Every country, every year

**Biyearly**
biyearly_country_pulse             # Every 2 years (religious flavor)

**Four-yearly**
four_yearly_country_pulse          # Every 4 years

**Conditional Pulses**
parliament_monthly_pulse           # Only during active parliament
in_regency_yearly_pulse            # Only during regency
country_pulse_for_high_infamy      # Only high-infamy countries

RULER & CHARACTER
----------------------------------
on_new_ruler
  # root = country
  # scope:old_ruler = previous ruler
  # scope:new_ruler = new ruler

on_ruler_death
  # root = country
  # scope:old_ruler = deceased ruler

on_character_birth
  # root = country
  # scope:character = newborn

on_character_death
  # root = country
  # scope:target = deceased character

on_character_marriage
  # root = primary character
  # scope:target = spouse

on_character_divorce
  # root = primary character
  # scope:target = ex-spouse

on_cabinet_assigned
  # root = country
  # scope:target = new cabinet member

on_cabinet_removed
  # root = country
  # scope:target = removed cabinet member

WAR & MILITARY
----------------------------------
on_war_declared
  # root = country (attacker)
  # scope:actor = attacker
  # scope:recipient = defender
  # scope:war = war object

on_battle_won
  # root = winner country
  # scope:actor = winning unit
  # scope:target = losing unit
  # scope:killed_land_units = casualties
  # scope:war_score = war score change

on_battle_lost
  # root = loser country
  # (same scopes as on_battle_won)

on_siege_won
  # root = country
  # scope:target = location
  # scope:character = commanding general

on_winning_war
  # root = country
  # scope:winner = winner country
  # scope:loser = loser country
  # scope:war = war object

on_losing_war
  # (same scopes as on_winning_war)

on_ending_war
  # Fires for both winner and loser
  # (same scopes as on_winning_war)

DIPLOMACY
----------------------------------
on_dependency_gained
  # root = country
  # scope:overlord = new overlord

on_becoming_free
  # root = country
  # scope:overlord = former overlord

on_annex
  # root = annexing country
  # scope:target = annexed country
  # Fires BEFORE annexation

on_annexed
  # root = annexing country
  # scope:target = annexed country
  # Fires AFTER annexation

on_royal_marriage
  # root = country
  # scope:actor = sender
  # scope:recipient = receiver
  # scope:target_1 = character from sender
  # scope:target_2 = character from receiver

LOCATION & TERRITORY
----------------------------------
on_location_changed_owner
  # root = location
  # scope:loser = previous owner
  # scope:winner = new owner

on_location_occupied
  # root = country
  # scope:target = location
  # scope:character = commanding general

on_capital_moved
  # root = country
  # scope:old_capital = old capital location
  # scope:new_capital = new capital location

GOVERNMENT & INSTITUTIONS
----------------------------------
on_government_type_change
  # root = country
  # scope:from = old government type
  # scope:to = new government type

on_religion_changed
  # root = country
  # scope:old_religion = previous religion

on_institution_embraced
  # root = country
  # scope:target = institution

on_election
  # root = country

on_parliament_passed
  # root = country
  # scope:target = parliament issue
  # scope:location = parliament seat

on_parliament_failed
  # root = country
  # scope:target = parliament issue
  # scope:location = parliament seat

SPECIAL EVENTS
----------------------------------
on_game_start
  # root = none
  # Fires once at game start

on_bankruptcy
  # root = country

on_gain_great_power_status
  # root = country

on_lose_great_power_status
  # root = country

======================
WEIGHT & RANDOM SELECTION
======================

BASIC WEIGHTS
----------------------------------
random_events = {
    100 = event_a.1         # Weight 100
    200 = event_b.1         # Weight 200 (2x more likely)
    50 = event_c.1          # Weight 50 (half as likely as event_a)
}

Probability:
- event_a: 100/350 = 28.6%
- event_b: 200/350 = 57.1%
- event_c: 50/350 = 14.3%

EVENT WEIGHT MULTIPLIERS
----------------------------------
Events can have their own weight_multiplier:

# Event definition:
event_a.1 = {
    weight_multiplier = {
        base = 1
        modifier = {
            add = 1
            stability >= 2  # Double weight if stable
        }
    }
}

# In on action:
random_events = {
    100 = event_a.1  # Effective weight: 100 or 200
    200 = event_b.1
}

CHANCE_TO_HAPPEN
----------------------------------
random_events = {
    chance_to_happen = 50  # 50% chance to evaluate at all
    
    100 = event_a.1
    100 = event_b.1
}

If chance_to_happen fails, NO events fire.

CHANCE_OF_NO_EVENT
----------------------------------
random_events = {
    chance_of_no_event = {
        value = 25
        if = {
            limit = { stability < 0 }
            add = 25  # 50% if unstable
        }
    }
    
    100 = event_a.1
    100 = event_b.1
}

Even if events are valid, may fire nothing.

NO EVENT WEIGHT
----------------------------------
random_events = {
    100 = event_a.1
    100 = event_b.1
    100 = 0           # 33% chance of no event
}

======================
PRACTICAL EXAMPLES
======================

EXAMPLE 1: Monthly Investigation System
----------------------------------
# Hook into monthly pulse:
on_monthly_pulse_country = {
    on_actions = {
        my_mod_investigation_pulse
    }
}

# Custom on action:
my_mod_investigation_pulse = {
    trigger = {
        has_variable = investigation_active
    }
    
    random_events = {
        chance_to_happen = 30
        
        200 = investigation_clue.1     # Find clue
        100 = investigation_setback.1  # Setback
        50 = investigation_breakthrough.1  # Major break
        150 = 0                        # Nothing happens
    }
}

EXAMPLE 2: Ruler Death Succession Events
----------------------------------
on_ruler_death = {
    on_actions = {
        my_mod_succession_handler
    }
}

my_mod_succession_handler = {
    first_valid = {
        succession_crisis.1      # Trigger if no heir
        succession_smooth.1      # Trigger if heir exists
        succession_regency.1     # Trigger if heir too young
    }
}

EXAMPLE 3: Delayed Event Chain
----------------------------------
my_mod_event_chain = {
    events = {
        chain.1                  # Fires immediately
        
        delay = { days = 30 }
        chain.2                  # 30 days later
        
        delay = { months = 3 }
        chain.3                  # 3 months after that
        
        delay = { years = 1 }
        chain.4                  # 1 year after that
    }
}

EXAMPLE 4: Conditional Battle Rewards
----------------------------------
on_battle_won = {
    on_actions = {
        my_mod_battle_rewards
    }
}

my_mod_battle_rewards = {
    trigger = {
        scope:killed_land_units >= 5000  # Major battle
    }
    
    effect = {
        add_prestige = 10
        
        scope:actor = {
            if = {
                limit = { is_general = yes }
                add_trait = battle_hero
            }
        }
    }
    
    random_events = {
        chance_to_happen = 25
        100 = battle_loot.1
        50 = battle_artifact.1
    }
}

EXAMPLE 5: Yearly Stability Check
----------------------------------
yearly_country_pulse = {
    on_actions = {
        my_mod_stability_check
    }
}

my_mod_stability_check = {
    trigger = {
        stability < 0
    }
    
    random_events = {
        chance_of_no_event = {
            value = 50
            if = {
                limit = { stability < -2 }
                add = -25  # More likely if very unstable
            }
        }
        
        100 = stability_crisis.1
        50 = stability_disaster.1
    }
}

======================
DEBUGGING ON ACTIONS
======================

CONSOLE COMMANDS
----------------------------------
debug_mode                         # Enable debug mode
reload on_actions                  # Reload on action files

LOGGING
----------------------------------
Add log statements to track execution:

my_on_action = {
    effect = {
        log = "My on action fired for [ROOT.GetName]"
    }
    
    events = {
        my_event.1
    }
}

COMMON ISSUES
----------------------------------
âŒ ERROR: On action not firing
Causes:
- Trigger returns false
- Hardcoded on action name misspelled
- Event triggers all return false

âœ… FIX: Check triggers, verify on action name

âŒ ERROR: Event fires at wrong time
Cause: Delay not working as expected

âœ… FIX: Remember validation happens both at trigger AND after delay

âŒ ERROR: Too many events firing
Cause: No weight for "no event"

âœ… FIX: Add weight = 0 entry or chance_of_no_event

âŒ ERROR: Events fire in wrong order
Cause: Relying on parallel execution order

âœ… FIX: Use ordered_list or chain events manually

======================
BEST PRACTICES
======================

1. **Use unique prefixes** for mod compatibility
2. **Test trigger conditions** thoroughly
3. **Add fallback events** for critical chains
4. **Use weights wisely** for balanced randomness
5. **Log important on actions** for debugging
6. **Document complex on action chains**
7. **Consider performance** (use events block, not effects, for many scopes)
8. **Validate delay behavior** with testing
9. **Provide fallback on actions** to prevent infinite loops
10. **Chain related events** in same on action for coherence

======================
CROSS-REFERENCES
======================
ðŸ“„ Related Files:
- EU5_EVENTS_REFERENCE.txt - Event structure and triggers
- EU5_EFFECTS_REFERENCE.txt - trigger_event effect
- EU5_TRIGGERS_REFERENCE.txt - On action trigger conditions
- EU5_SCOPES_REFERENCE.txt - Understanding scope context
- EU5_VARIABLES_REFERENCE.txt - Using variables in on actions
- common/on_action/ - Vanilla on actions
- game/in_game/common/on_action/_on_actions.info - Official documentation
